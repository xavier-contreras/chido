# -*- coding: utf-8 -*-
# pylint:skip-file
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_config_openconfig_ap_manager__provision_aps_provision_ap_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ap-manager - based on the path /provision-aps/provision-ap/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Config container for assigning hostnames to APs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mac','__hostname','__country_code',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mac = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-yang:mac-address', is_config=True)
    self.__hostname = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:domain-name', is_config=True)
    self.__country_code = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'[A-Z]{2}'}), is_leaf=True, yang_name="country-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'provision-aps', u'provision-ap', u'config']

  def _get_mac(self):
    """
    Getter method for mac, mapped from YANG variable /provision_aps/provision_ap/config/mac (oc-yang:mac-address)

    YANG Description: MAC address of the AP primary Ethernet interface. If AP
has multiple Ethernet interfaces, this would be the MAC printed
on the unit label and referenced within the management system.
Vendors MUST reject attempts to configure this leaf.
    """
    return self.__mac

  def _set_mac(self, v, load=False):
    """
    Setter method for mac, mapped from YANG variable /provision_aps/provision_ap/config/mac (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac() directly.

    YANG Description: MAC address of the AP primary Ethernet interface. If AP
has multiple Ethernet interfaces, this would be the MAC printed
on the unit label and referenced within the management system.
Vendors MUST reject attempts to configure this leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-yang:mac-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-yang:mac-address', is_config=True)""",
        })

    self.__mac = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac(self):
    self.__mac = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-yang:mac-address', is_config=True)


  def _get_hostname(self):
    """
    Getter method for hostname, mapped from YANG variable /provision_aps/provision_ap/config/hostname (oc-inet:domain-name)

    YANG Description: Hostname of the Access Point.
    """
    return self.__hostname

  def _set_hostname(self, v, load=False):
    """
    Setter method for hostname, mapped from YANG variable /provision_aps/provision_ap/config/hostname (oc-inet:domain-name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hostname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hostname() directly.

    YANG Description: Hostname of the Access Point.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:domain-name', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hostname must be of a type compatible with oc-inet:domain-name""",
          'defined-type': "oc-inet:domain-name",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:domain-name', is_config=True)""",
        })

    self.__hostname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hostname(self):
    self.__hostname = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:domain-name', is_config=True)


  def _get_country_code(self):
    """
    Getter method for country_code, mapped from YANG variable /provision_aps/provision_ap/config/country_code (string)

    YANG Description: Country code where the AP operates in ISO 3166-1 alpha-2
format.
    """
    return self.__country_code

  def _set_country_code(self, v, load=False):
    """
    Setter method for country_code, mapped from YANG variable /provision_aps/provision_ap/config/country_code (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_country_code is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_country_code() directly.

    YANG Description: Country code where the AP operates in ISO 3166-1 alpha-2
format.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'[A-Z]{2}'}), is_leaf=True, yang_name="country-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """country_code must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'[A-Z]{2}'}), is_leaf=True, yang_name="country-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=True)""",
        })

    self.__country_code = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_country_code(self):
    self.__country_code = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'[A-Z]{2}'}), is_leaf=True, yang_name="country-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=True)

  mac = __builtin__.property(_get_mac, _set_mac)
  hostname = __builtin__.property(_get_hostname, _set_hostname)
  country_code = __builtin__.property(_get_country_code, _set_country_code)


  _pyangbind_elements = OrderedDict([('mac', mac), ('hostname', hostname), ('country_code', country_code), ])


class yc_state_openconfig_ap_manager__provision_aps_provision_ap_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ap-manager - based on the path /provision-aps/provision-ap/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State container for assigning hostnames to APs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mac','__hostname','__country_code',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mac = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-yang:mac-address', is_config=False)
    self.__hostname = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:domain-name', is_config=False)
    self.__country_code = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'[A-Z]{2}'}), is_leaf=True, yang_name="country-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'provision-aps', u'provision-ap', u'state']

  def _get_mac(self):
    """
    Getter method for mac, mapped from YANG variable /provision_aps/provision_ap/state/mac (oc-yang:mac-address)

    YANG Description: MAC address of the AP primary Ethernet interface. If AP
has multiple Ethernet interfaces, this would be the MAC printed
on the unit label and referenced within the management system.
Vendors MUST reject attempts to configure this leaf.
    """
    return self.__mac

  def _set_mac(self, v, load=False):
    """
    Setter method for mac, mapped from YANG variable /provision_aps/provision_ap/state/mac (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac() directly.

    YANG Description: MAC address of the AP primary Ethernet interface. If AP
has multiple Ethernet interfaces, this would be the MAC printed
on the unit label and referenced within the management system.
Vendors MUST reject attempts to configure this leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-yang:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-yang:mac-address', is_config=False)""",
        })

    self.__mac = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac(self):
    self.__mac = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-yang:mac-address', is_config=False)


  def _get_hostname(self):
    """
    Getter method for hostname, mapped from YANG variable /provision_aps/provision_ap/state/hostname (oc-inet:domain-name)

    YANG Description: Hostname of the Access Point.
    """
    return self.__hostname

  def _set_hostname(self, v, load=False):
    """
    Setter method for hostname, mapped from YANG variable /provision_aps/provision_ap/state/hostname (oc-inet:domain-name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hostname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hostname() directly.

    YANG Description: Hostname of the Access Point.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:domain-name', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hostname must be of a type compatible with oc-inet:domain-name""",
          'defined-type': "oc-inet:domain-name",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:domain-name', is_config=False)""",
        })

    self.__hostname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hostname(self):
    self.__hostname = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:domain-name', is_config=False)


  def _get_country_code(self):
    """
    Getter method for country_code, mapped from YANG variable /provision_aps/provision_ap/state/country_code (string)

    YANG Description: Country code where the AP operates in ISO 3166-1 alpha-2
format.
    """
    return self.__country_code

  def _set_country_code(self, v, load=False):
    """
    Setter method for country_code, mapped from YANG variable /provision_aps/provision_ap/state/country_code (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_country_code is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_country_code() directly.

    YANG Description: Country code where the AP operates in ISO 3166-1 alpha-2
format.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'[A-Z]{2}'}), is_leaf=True, yang_name="country-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """country_code must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'[A-Z]{2}'}), is_leaf=True, yang_name="country-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)""",
        })

    self.__country_code = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_country_code(self):
    self.__country_code = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'[A-Z]{2}'}), is_leaf=True, yang_name="country-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)

  mac = __builtin__.property(_get_mac)
  hostname = __builtin__.property(_get_hostname)
  country_code = __builtin__.property(_get_country_code)


  _pyangbind_elements = OrderedDict([('mac', mac), ('hostname', hostname), ('country_code', country_code), ])


class yc_provision_ap_openconfig_ap_manager__provision_aps_provision_ap(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ap-manager - based on the path /provision-aps/provision-ap. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of MAC addresses that will have hostnames assigned.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mac','__config','__state',)

  _yang_name = 'provision-ap'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mac = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_ap_manager__provision_aps_provision_ap_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_ap_manager__provision_aps_provision_ap_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'provision-aps', u'provision-ap']

  def _get_mac(self):
    """
    Getter method for mac, mapped from YANG variable /provision_aps/provision_ap/mac (leafref)

    YANG Description: Reference to the MAC address list key. This leaf is a reference
only and not to be configured.
    """
    return self.__mac

  def _set_mac(self, v, load=False):
    """
    Setter method for mac, mapped from YANG variable /provision_aps/provision_ap/mac (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac() directly.

    YANG Description: Reference to the MAC address list key. This leaf is a reference
only and not to be configured.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='leafref', is_config=True)""",
        })

    self.__mac = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac(self):
    self.__mac = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /provision_aps/provision_ap/config (container)

    YANG Description: Config container for assigning hostnames to APs.
    """
    return self.__config

  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /provision_aps/provision_ap/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Config container for assigning hostnames to APs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_ap_manager__provision_aps_provision_ap_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_ap_manager__provision_aps_provision_ap_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_ap_manager__provision_aps_provision_ap_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /provision_aps/provision_ap/state (container)

    YANG Description: State container for assigning hostnames to APs.
    """
    return self.__state

  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /provision_aps/provision_ap/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State container for assigning hostnames to APs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_ap_manager__provision_aps_provision_ap_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_ap_manager__provision_aps_provision_ap_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_ap_manager__provision_aps_provision_ap_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)

  mac = __builtin__.property(_get_mac, _set_mac)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('mac', mac), ('config', config), ('state', state), ])


class yc_provision_aps_openconfig_ap_manager__provision_aps(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ap-manager - based on the path /provision-aps. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top most container for assigning hostnames to APs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__provision_ap',)

  _yang_name = 'provision-aps'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__provision_ap = YANGDynClass(base=YANGListType("mac",yc_provision_ap_openconfig_ap_manager__provision_aps_provision_ap, yang_name="provision-ap", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mac', extensions=None), is_container='list', yang_name="provision-ap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'provision-aps']

  def _get_provision_ap(self):
    """
    Getter method for provision_ap, mapped from YANG variable /provision_aps/provision_ap (list)

    YANG Description: List of MAC addresses that will have hostnames assigned.
    """
    return self.__provision_ap

  def _set_provision_ap(self, v, load=False):
    """
    Setter method for provision_ap, mapped from YANG variable /provision_aps/provision_ap (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_provision_ap is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_provision_ap() directly.

    YANG Description: List of MAC addresses that will have hostnames assigned.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("mac",yc_provision_ap_openconfig_ap_manager__provision_aps_provision_ap, yang_name="provision-ap", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mac', extensions=None), is_container='list', yang_name="provision-ap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """provision_ap must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("mac",yc_provision_ap_openconfig_ap_manager__provision_aps_provision_ap, yang_name="provision-ap", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mac', extensions=None), is_container='list', yang_name="provision-ap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='list', is_config=True)""",
        })

    self.__provision_ap = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_provision_ap(self):
    self.__provision_ap = YANGDynClass(base=YANGListType("mac",yc_provision_ap_openconfig_ap_manager__provision_aps_provision_ap, yang_name="provision-ap", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='mac', extensions=None), is_container='list', yang_name="provision-ap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='list', is_config=True)

  provision_ap = __builtin__.property(_get_provision_ap, _set_provision_ap)


  _pyangbind_elements = OrderedDict([('provision_ap', provision_ap), ])


class yc_state_openconfig_ap_manager__joined_aps_joined_ap_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ap-manager - based on the path /joined-aps/joined-ap/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State container for Joined APs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mac','__hostname','__opstate','__uptime','__enabled','__serial','__model','__software_version','__ipv4','__ipv6','__power_source',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__uptime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="uptime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='uint32', is_config=False)
    self.__software_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)
    self.__hostname = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:domain-name', is_config=False)
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='boolean', is_config=False)
    self.__opstate = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi:UP': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi:DOWN': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:UPGRADING': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DOWN': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi:UPGRADING': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'UPGRADING': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'UP': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'DOWN': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:UP': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="opstate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='identityref', is_config=False)
    self.__mac = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-yang:mac-address', is_config=False)
    self.__ipv4 = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}), is_leaf=True, yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:ipv4-address', is_config=False)
    self.__ipv6 = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}), is_leaf=True, yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:ipv6-address', is_config=False)
    self.__power_source = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PLUG': {}, u'AT': {}, u'AF': {}},), is_leaf=True, yang_name="power-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='enumeration', is_config=False)
    self.__serial = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="serial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)
    self.__model = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="model", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'joined-aps', u'joined-ap', u'state']

  def _get_mac(self):
    """
    Getter method for mac, mapped from YANG variable /joined_aps/joined_ap/state/mac (oc-yang:mac-address)

    YANG Description: MAC address of the AP primary Ethernet interface. If AP
has multiple Ethernet interfaces, this would be the MAC printed
on the unit label and referenced within the management system.
Vendors MUST reject attempts to configure this leaf.
    """
    return self.__mac

  def _set_mac(self, v, load=False):
    """
    Setter method for mac, mapped from YANG variable /joined_aps/joined_ap/state/mac (oc-yang:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac() directly.

    YANG Description: MAC address of the AP primary Ethernet interface. If AP
has multiple Ethernet interfaces, this would be the MAC printed
on the unit label and referenced within the management system.
Vendors MUST reject attempts to configure this leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-yang:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac must be of a type compatible with oc-yang:mac-address""",
          'defined-type': "oc-yang:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-yang:mac-address', is_config=False)""",
        })

    self.__mac = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac(self):
    self.__mac = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}$'}), is_leaf=True, yang_name="mac", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-yang:mac-address', is_config=False)


  def _get_hostname(self):
    """
    Getter method for hostname, mapped from YANG variable /joined_aps/joined_ap/state/hostname (oc-inet:domain-name)

    YANG Description: Hostname of the Access Point.
    """
    return self.__hostname

  def _set_hostname(self, v, load=False):
    """
    Setter method for hostname, mapped from YANG variable /joined_aps/joined_ap/state/hostname (oc-inet:domain-name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hostname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hostname() directly.

    YANG Description: Hostname of the Access Point.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:domain-name', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hostname must be of a type compatible with oc-inet:domain-name""",
          'defined-type': "oc-inet:domain-name",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:domain-name', is_config=False)""",
        })

    self.__hostname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hostname(self):
    self.__hostname = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'((([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.)*([a-zA-Z0-9_]([a-zA-Z0-9\\-_]){0,61})?[a-zA-Z0-9]\\.?)|\\.', u'length': [u'1..253']}), is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:domain-name', is_config=False)


  def _get_opstate(self):
    """
    Getter method for opstate, mapped from YANG variable /joined_aps/joined_ap/state/opstate (identityref)

    YANG Description: The current operational state of the AP.
    """
    return self.__opstate

  def _set_opstate(self, v, load=False):
    """
    Setter method for opstate, mapped from YANG variable /joined_aps/joined_ap/state/opstate (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opstate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opstate() directly.

    YANG Description: The current operational state of the AP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi:UP': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi:DOWN': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:UPGRADING': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DOWN': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi:UPGRADING': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'UPGRADING': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'UP': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'DOWN': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:UP': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="opstate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opstate must be of a type compatible with identityref""",
          'defined-type': "openconfig-ap-manager:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi:UP': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi:DOWN': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:UPGRADING': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DOWN': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi:UPGRADING': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'UPGRADING': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'UP': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'DOWN': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:UP': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="opstate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='identityref', is_config=False)""",
        })

    self.__opstate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opstate(self):
    self.__opstate = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'oc-wifi:UP': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi:DOWN': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:UPGRADING': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:DOWN': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi:UPGRADING': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'UPGRADING': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'UP': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'DOWN': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}, u'oc-wifi-types:UP': {u'@namespace': u'http://openconfig.net/yang/wifi/types', u'@module': u'openconfig-wifi-types'}},), is_leaf=True, yang_name="opstate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='identityref', is_config=False)


  def _get_uptime(self):
    """
    Getter method for uptime, mapped from YANG variable /joined_aps/joined_ap/state/uptime (uint32)

    YANG Description: Seconds this AP has been in the op-state of 'UP'.
    """
    return self.__uptime

  def _set_uptime(self, v, load=False):
    """
    Setter method for uptime, mapped from YANG variable /joined_aps/joined_ap/state/uptime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uptime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uptime() directly.

    YANG Description: Seconds this AP has been in the op-state of 'UP'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="uptime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uptime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="uptime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='uint32', is_config=False)""",
        })

    self.__uptime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uptime(self):
    self.__uptime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="uptime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='uint32', is_config=False)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /joined_aps/joined_ap/state/enabled (boolean)

    YANG Description: Whether the AP is enabled or disabled.
    """
    return self.__enabled

  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /joined_aps/joined_ap/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Whether the AP is enabled or disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='boolean', is_config=False)


  def _get_serial(self):
    """
    Getter method for serial, mapped from YANG variable /joined_aps/joined_ap/state/serial (string)

    YANG Description: Serial number of the Access Point.
    """
    return self.__serial

  def _set_serial(self, v, load=False):
    """
    Setter method for serial, mapped from YANG variable /joined_aps/joined_ap/state/serial (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_serial is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_serial() directly.

    YANG Description: Serial number of the Access Point.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="serial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """serial must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="serial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)""",
        })

    self.__serial = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_serial(self):
    self.__serial = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="serial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)


  def _get_model(self):
    """
    Getter method for model, mapped from YANG variable /joined_aps/joined_ap/state/model (string)

    YANG Description: Model number of the Access Point.
    """
    return self.__model

  def _set_model(self, v, load=False):
    """
    Setter method for model, mapped from YANG variable /joined_aps/joined_ap/state/model (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_model is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_model() directly.

    YANG Description: Model number of the Access Point.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="model", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """model must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="model", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)""",
        })

    self.__model = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_model(self):
    self.__model = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="model", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)


  def _get_software_version(self):
    """
    Getter method for software_version, mapped from YANG variable /joined_aps/joined_ap/state/software_version (string)

    YANG Description: Software version of the Access Point.
    """
    return self.__software_version

  def _set_software_version(self, v, load=False):
    """
    Setter method for software_version, mapped from YANG variable /joined_aps/joined_ap/state/software_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_software_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_software_version() directly.

    YANG Description: Software version of the Access Point.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """software_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)""",
        })

    self.__software_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_software_version(self):
    self.__software_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='string', is_config=False)


  def _get_ipv4(self):
    """
    Getter method for ipv4, mapped from YANG variable /joined_aps/joined_ap/state/ipv4 (oc-inet:ipv4-address)

    YANG Description: The IPv4 address of the Access Point.
    """
    return self.__ipv4

  def _set_ipv4(self, v, load=False):
    """
    Setter method for ipv4, mapped from YANG variable /joined_aps/joined_ap/state/ipv4 (oc-inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4() directly.

    YANG Description: The IPv4 address of the Access Point.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}), is_leaf=True, yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4 must be of a type compatible with oc-inet:ipv4-address""",
          'defined-type': "oc-inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}), is_leaf=True, yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:ipv4-address', is_config=False)""",
        })

    self.__ipv4 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4(self):
    self.__ipv4 = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$'}), is_leaf=True, yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:ipv4-address', is_config=False)


  def _get_ipv6(self):
    """
    Getter method for ipv6, mapped from YANG variable /joined_aps/joined_ap/state/ipv6 (oc-inet:ipv6-address)

    YANG Description: The IPv6 address of the Access Point.
    """
    return self.__ipv6

  def _set_ipv6(self, v, load=False):
    """
    Setter method for ipv6, mapped from YANG variable /joined_aps/joined_ap/state/ipv6 (oc-inet:ipv6-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6() directly.

    YANG Description: The IPv6 address of the Access Point.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}), is_leaf=True, yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:ipv6-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6 must be of a type compatible with oc-inet:ipv6-address""",
          'defined-type': "oc-inet:ipv6-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}), is_leaf=True, yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:ipv6-address', is_config=False)""",
        })

    self.__ipv6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6(self):
    self.__ipv6 = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={u'pattern': u'^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$'}), is_leaf=True, yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='oc-inet:ipv6-address', is_config=False)


  def _get_power_source(self):
    """
    Getter method for power_source, mapped from YANG variable /joined_aps/joined_ap/state/power_source (enumeration)

    YANG Description: Enumerate how the AP is being powered.
    """
    return self.__power_source

  def _set_power_source(self, v, load=False):
    """
    Setter method for power_source, mapped from YANG variable /joined_aps/joined_ap/state/power_source (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_power_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_power_source() directly.

    YANG Description: Enumerate how the AP is being powered.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PLUG': {}, u'AT': {}, u'AF': {}},), is_leaf=True, yang_name="power-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """power_source must be of a type compatible with enumeration""",
          'defined-type': "openconfig-ap-manager:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PLUG': {}, u'AT': {}, u'AF': {}},), is_leaf=True, yang_name="power-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='enumeration', is_config=False)""",
        })

    self.__power_source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_power_source(self):
    self.__power_source = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={u'PLUG': {}, u'AT': {}, u'AF': {}},), is_leaf=True, yang_name="power-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='enumeration', is_config=False)

  mac = __builtin__.property(_get_mac)
  hostname = __builtin__.property(_get_hostname)
  opstate = __builtin__.property(_get_opstate)
  uptime = __builtin__.property(_get_uptime)
  enabled = __builtin__.property(_get_enabled)
  serial = __builtin__.property(_get_serial)
  model = __builtin__.property(_get_model)
  software_version = __builtin__.property(_get_software_version)
  ipv4 = __builtin__.property(_get_ipv4)
  ipv6 = __builtin__.property(_get_ipv6)
  power_source = __builtin__.property(_get_power_source)


  _pyangbind_elements = OrderedDict([('mac', mac), ('hostname', hostname), ('opstate', opstate), ('uptime', uptime), ('enabled', enabled), ('serial', serial), ('model', model), ('software_version', software_version), ('ipv4', ipv4), ('ipv6', ipv6), ('power_source', power_source), ])


class yc_joined_ap_openconfig_ap_manager__joined_aps_joined_ap(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ap-manager - based on the path /joined-aps/joined-ap. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of access points that have joined the controller.
  """
  __slots__ = ('_path_helper', '_extmethods', '__hostname','__state',)

  _yang_name = 'joined-ap'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__state = YANGDynClass(base=yc_state_openconfig_ap_manager__joined_aps_joined_ap_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=False)
    self.__hostname = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'joined-aps', u'joined-ap']

  def _get_hostname(self):
    """
    Getter method for hostname, mapped from YANG variable /joined_aps/joined_ap/hostname (leafref)

    YANG Description: Reference to the MAC address list key.
    """
    return self.__hostname

  def _set_hostname(self, v, load=False):
    """
    Setter method for hostname, mapped from YANG variable /joined_aps/joined_ap/hostname (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hostname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hostname() directly.

    YANG Description: Reference to the MAC address list key.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hostname must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='leafref', is_config=False)""",
        })

    self.__hostname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hostname(self):
    self.__hostname = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hostname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='leafref', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /joined_aps/joined_ap/state (container)

    YANG Description: State container for Joined APs.
    """
    return self.__state

  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /joined_aps/joined_ap/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: State container for Joined APs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_ap_manager__joined_aps_joined_ap_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_ap_manager__joined_aps_joined_ap_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_ap_manager__joined_aps_joined_ap_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=False)

  hostname = __builtin__.property(_get_hostname)
  state = __builtin__.property(_get_state)


  _pyangbind_elements = OrderedDict([('hostname', hostname), ('state', state), ])


class yc_joined_aps_openconfig_ap_manager__joined_aps(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ap-manager - based on the path /joined-aps. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top most container for joined-aps.
  """
  __slots__ = ('_path_helper', '_extmethods', '__joined_ap',)

  _yang_name = 'joined-aps'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__joined_ap = YANGDynClass(base=YANGListType("hostname",yc_joined_ap_openconfig_ap_manager__joined_aps_joined_ap, yang_name="joined-ap", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='hostname', extensions=None), is_container='list', yang_name="joined-ap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'joined-aps']

  def _get_joined_ap(self):
    """
    Getter method for joined_ap, mapped from YANG variable /joined_aps/joined_ap (list)

    YANG Description: List of access points that have joined the controller.
    """
    return self.__joined_ap

  def _set_joined_ap(self, v, load=False):
    """
    Setter method for joined_ap, mapped from YANG variable /joined_aps/joined_ap (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_joined_ap is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_joined_ap() directly.

    YANG Description: List of access points that have joined the controller.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("hostname",yc_joined_ap_openconfig_ap_manager__joined_aps_joined_ap, yang_name="joined-ap", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='hostname', extensions=None), is_container='list', yang_name="joined-ap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """joined_ap must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("hostname",yc_joined_ap_openconfig_ap_manager__joined_aps_joined_ap, yang_name="joined-ap", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='hostname', extensions=None), is_container='list', yang_name="joined-ap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='list', is_config=True)""",
        })

    self.__joined_ap = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_joined_ap(self):
    self.__joined_ap = YANGDynClass(base=YANGListType("hostname",yc_joined_ap_openconfig_ap_manager__joined_aps_joined_ap, yang_name="joined-ap", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='hostname', extensions=None), is_container='list', yang_name="joined-ap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='list', is_config=True)

  joined_ap = __builtin__.property(_get_joined_ap, _set_joined_ap)


  _pyangbind_elements = OrderedDict([('joined_ap', joined_ap), ])


class openconfig_ap_manager(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ap-manager - based on the path /openconfig-ap-manager. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines the top level configuration and state data for a
system which manages Access Points.
  """
  __slots__ = ('_path_helper', '_extmethods', '__provision_aps','__joined_aps',)

  _yang_name = 'openconfig-ap-manager'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__joined_aps = YANGDynClass(base=yc_joined_aps_openconfig_ap_manager__joined_aps, is_container='container', yang_name="joined-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)
    self.__provision_aps = YANGDynClass(base=yc_provision_aps_openconfig_ap_manager__provision_aps, is_container='container', yang_name="provision-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_provision_aps(self):
    """
    Getter method for provision_aps, mapped from YANG variable /provision_aps (container)

    YANG Description: Top most container for assigning hostnames to APs.
    """
    return self.__provision_aps

  def _set_provision_aps(self, v, load=False):
    """
    Setter method for provision_aps, mapped from YANG variable /provision_aps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_provision_aps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_provision_aps() directly.

    YANG Description: Top most container for assigning hostnames to APs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_provision_aps_openconfig_ap_manager__provision_aps, is_container='container', yang_name="provision-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """provision_aps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_provision_aps_openconfig_ap_manager__provision_aps, is_container='container', yang_name="provision-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)""",
        })

    self.__provision_aps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_provision_aps(self):
    self.__provision_aps = YANGDynClass(base=yc_provision_aps_openconfig_ap_manager__provision_aps, is_container='container', yang_name="provision-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)


  def _get_joined_aps(self):
    """
    Getter method for joined_aps, mapped from YANG variable /joined_aps (container)

    YANG Description: Top most container for joined-aps.
    """
    return self.__joined_aps

  def _set_joined_aps(self, v, load=False):
    """
    Setter method for joined_aps, mapped from YANG variable /joined_aps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_joined_aps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_joined_aps() directly.

    YANG Description: Top most container for joined-aps.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_joined_aps_openconfig_ap_manager__joined_aps, is_container='container', yang_name="joined-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """joined_aps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_joined_aps_openconfig_ap_manager__joined_aps, is_container='container', yang_name="joined-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)""",
        })

    self.__joined_aps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_joined_aps(self):
    self.__joined_aps = YANGDynClass(base=yc_joined_aps_openconfig_ap_manager__joined_aps, is_container='container', yang_name="joined-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)

  provision_aps = __builtin__.property(_get_provision_aps, _set_provision_aps)
  joined_aps = __builtin__.property(_get_joined_aps, _set_joined_aps)


  _pyangbind_elements = OrderedDict([('provision_aps', provision_aps), ('joined_aps', joined_aps), ])
